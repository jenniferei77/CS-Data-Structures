int count_vocab(string[] vocab, int[] freq, int v,
                string corpus, bool fast)
//@requires v == \length(vocab) && v == \length(freq);
//@requires is_sorted(vocab, 0, v);
{
  //reads in the corpus array to use
  bundle_t words_bundle = read_words(corpus);
  int w = string_bundle_length(words_bundle);
  string[] words = string_bundle_array(words_bundle);
  int occurs = w;
  int in_there = 0;

  for(int i = 0; i < w; i++)
  //@loop_invariant 0 <= i && i <= w;

  {
    if (!fast)
    {
      in_there = linsearch(words[i], vocab, v);
    }
    else
    {
      in_there = binsearch(words[i], vocab, v);
    }
    if (in_there >= 0)
    {
      occurs--;
      freq[in_there]++;
    }
  }

  return occurs;

}

void merge(int[] freq, string[] vocab, int lo, int mid, int hi)
//@requires 0 <= lo && lo <= mid && mid <= hi && hi <= \length(freq);
//@requires is_sorted_int(freq, lo, mid) && is_sorted_int(freq, mid, hi);
//@ensures is_sorted_int(freq, lo, hi);
{
  int[] freq_temp = alloc_array(int, hi-lo);
  string[] vocab_temp = alloc_array(string, hi-lo);
  int i = lo;
  int j = mid;
  int k = 0;

  while (i < mid && j < hi)
  //@loop_invariant lo <= i && i <= mid;
  //@loop_invariant mid <= j && j <= hi;
  //@loop_invariant k == (i - lo) + (j - mid);
  {
    if (freq[i] <= freq[j])
    {
      if (freq[i] == freq[j])
      {
        if (string_compare(vocab[i],vocab[j]) == -1)
        {
          freq_temp[k] = freq[i];
          vocab_temp[k] = vocab[i];
          i++;
        }
        else
        {
          //@assert string_compare(vocab[i],vocab[j]) > -1;
          freq_temp[k] = freq[j];
          vocab_temp[k] = vocab[j];
          j++;
        }
      }
      else
      {
        //@assert freq[i] < freq[j];
        freq_temp[k] = freq[i];
        vocab_temp[k] = vocab[i];
        i++;
      }
    }
    else
    {
      //@assert freq[i] > freq[j];
      freq_temp[k] = freq[j];
      vocab_temp[k] = vocab[j];
      j++;
    }
    k++;
  }

  //@assert i == mid || j == hi;
  while (i < mid)
  //@loop_invariant 0 <= i && i <= mid;
  {
    freq_temp[k] = freq[i];
    vocab_temp[k] = vocab[i];
    i++;
    k++;
  }
  while (j < hi)
  //@loop_invariant 0 <= j && j <= hi;
  {
    freq_temp[k] = freq[j];
    vocab_temp[k] = vocab[j];
    j++;
    k++;
  }

  //Copy sorted array back into freq
  for (k = 0; k < hi-lo; k++)
  //@loop_invariant 0 <= k && k <= (hi-lo);
  {
    freq[lo+k] = freq_temp[k];
    vocab[lo+k] = vocab_temp[k];
  }

}

void mergesort(int[] freq, string[] vocab, int lo, int hi)
//@requires 0 <= lo && lo <= hi && hi <= \length(freq);
//@ensures is_sorted_int(freq, lo, hi);
//Used the outline of mergesort code from Lecture 8
//Code, sort.c0 for this function
{
  if (hi-lo <= 1) return;

  int mid = lo + (hi - lo)/2;
  //@assert lo < mid && mid < hi;
  mergesort(freq, vocab, lo, mid);
  mergesort(freq, vocab, mid, hi);
  merge(freq, vocab, lo, mid, hi);
  return;

}
void sort_by_freq(string[] vocab, int[] freq, int v)
//@requires v == \length(vocab) && v == \length(freq);
//@ensures is_sorted_int(freq, 0, v);
{
  mergesort(freq, vocab, 0, v);
}

